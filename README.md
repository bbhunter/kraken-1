<h1 align="center">Kraken</h1> 

<p align="center">
  <img src="/img/logo.png" alt="kraken"/>
</p>

<p align="center">
    <a href="https://github.com/hnsecurity/kraken"><img src="https://img.shields.io/github/stars/hnsecurity/kraken.svg"></a>
    <a href="https://github.com/hnsecurity/kraken"><img src="https://img.shields.io/github/forks/hnsecurity/kraken.svg"></a>
    <a href="https://github.com/hnsecurity/kraken/issues"><img src="https://img.shields.io/github/issues-raw/hnsecurity/kraken.svg"></a>
    <a href="/LICENSE.txt"><img src="https://img.shields.io/badge/license-MIT-blueviolet"></a>
    <!--a href="#"><img src="https://img.shields.io/badge/release-1.0-blueviolet"></a-->
</p>




<p align="center">
    <b>Generate a report with charts and statistics about cracked passwords in XLSX format</b>
</p>
<p align="center">
    <a href="#introduction">Introduction</a>   
    •
    <a href="#authors">Authors</a>   
    •
    <a href="#features">Features</a>   
    •
    <a href="#usage">Usage</a>
    <br/>
</p>

<p align="center">
  For more information check out <a href="https://security.humanativaspa.it/cracked-password-analytics-with-kraken/">this article</a>
</p>
<hr>


## Introduction
During our assessments, it's common to get our hands on some <strong>hashed passwords</strong>, often related to an Active Directory (AD) domain. A password dump is usually obtained after compromising a domain controller and it contains the password hash of every account configured in the domain. In the Windows AD case, this hash is usually an NTLM hash, which doesn't offer strong protection against brute force and dictionary attacks.

</div>
<div>

At this stage, we usually start a <strong>password cracking</strong> attack on the dumped hashes to assess the strength of the passwords used to access the domain's accounts. And guess what? Users' passwords are usually weak!

This step allows us to get an overview of both the effectiveness of the password policies implemented in the domain and the awareness on the importance of strong passwords. We believe that this information is crucial to assess the security of an organization and, if presented correctly, it can have a significant impact on improving its security posture. However, the critical point is to present the results of this analysis in the best way possible.

First of all, we need to avoid giving the chance of blaming the users or, even worse, finding a scapegoat to blame for the analysis results. The focus should always be on <strong>password policies</strong> and the importance of <strong>security awareness</strong> in the employees, never on single cases. For this reason, we anonymize the report, excluding any information that would allow identifying the users.

Then, we need to show the impact of the analysis. Indeed, the list of cracked passwords doesn't provide a lot of information and it is not very useful by itself. For this reason, we need to aggregate the results and <strong>extract some useful statistics</strong>.

To speed up and standardize this process we developed Kraken. Even if Kraken is designed to integrate with the workflow that we usually follow in this type of activity on Windows AD, it could also be used for similar activities that require password cracking (e.g. Azure AD, LDAP) with minor modifications.

  
 ## Authors
- Maurizio Agazzini, Principal Security Analyst at HN Security &nbsp; <a href="https://twitter.com/0x696e6f6465"><img src="https://img.shields.io/twitter/follow/0x696e6f6465?label=%400x696e6f6465&style=social"></a>
- Stefano Alberto, Security Analyst at HN Security &nbsp; <a href="https://twitter.com/XatoPhi"><img style="vertical-align:middle" src="https://img.shields.io/twitter/follow/xatophi?label=%40xatophi&style=social"></a>
 
  
 ## Features

Kraken performs <strong>different types of analytics</strong> to visualize the results from different points of view, trying to identify patterns in the provided data. We will now take a brief look at the charts automatically generated by Kraken.
<h4><strong>Password analysis</strong></h4>
This chart is pretty simple, yet crucial in understanding the impact of the analysis. It shows <strong>how many of the passwords we were able to crack</strong>, giving an immediate idea of the overall security posture.
<div>
<br>

<p align="center">
  <img class="aligncenter wp-image-2133 size-large" src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/04/password_analysis-e1682347074881-1024x505.png" alt="" width="640" height="316" />
</p>
  
</div>
<h4><strong>Character analysis</strong></h4>
In this step we analyze the <strong>charset used in the cracked passwords</strong>. This is important to show potential flaws in the implemented password policy. If we can identify a prevalence of passwords that are based on small charsets we should probably consider implementing a more strict password policy. However, this chart should be interpreted carefully, knowing that it's biased because we are considering only the passwords that were successfully cracked. To address this bias, you can also include the not-cracked passwords in this chart by using the <code>show-not-cracked</code> option.

</div>
<br>

 <p align="center">
   <img class="aligncenter wp-image-2132 size-large" src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/04/character_analysis-e1682347161799-1024x504.png" alt="" width="640" height="315" />
 </p>
 
<div>
<h4><strong>Length analysis</strong></h4>
This analysis is self explanatory, we want to check the <strong>length of the cracked passwords</strong>. This allows to evaluate the implemented password policy and identify possible flaws. As in the character analysis, we need to be aware that this chart is biased against the shorter passwords that are easier to crack. Also in this case, the <code>show-not-cracked</code> option can be used.

</div>
<br>

<p align="center">
<img class="aligncenter wp-image-2134 size-large" src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/04/password_length-e1682347189924-1024x507.png" alt="" width="640" height="317" />
</p>
<div>
<h4><strong>Topology analysis</strong></h4>
With this analysis, we try to highlight <strong>patterns in cracked passwords</strong>. The tool will automatically categorize some of the passwords based on some basic patterns. For example, we look for passwords that are based on the username or are composed of repeated words, adding more context to the chart. Typical examples are passwords that contain the name of the company or the year when the password was changed. We can simply add custom categories that will be used in this analysis with the <code>dictionary</code> and the <code>regex</code> options.

</div>
<div>
<br>

<p align="center">
  <img class="aligncenter wp-image-2135 size-large" src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/04/password_topology-e1682347110451-1024x504.png" alt="" width="640" height="315" />
 </p>
</div>
<div>
<h4><strong>Leaked passwords analysis</strong></h4>
This is an optional analysis that checks automatically the <strong>presence of cracked credentials in public data breaches</strong>. It gives us an overview of the safety of passwords based on real data, allowing us to get another point of view on password strength. <strong>This check is done anonymously, the cleartext passwords never leave the device to guarantee password safety</strong>. We implemented this feature using two different services:

<strong>haveibeenpwned</strong>

This API offered by <a href="https://haveibeenpwned.com/Passwords">haveibeenpwned</a> checks for the presence of the password in a database with hundreds of millions of real-world passwords previously exposed in data breaches.

<strong>Google password manager</strong>

This service checks for the user and password pair inside a database of leaked credentials. For more information about the design of this API, you can check out <a href="https://security.googleblog.com/2019/02/protect-your-accounts-from-data.html">this blog post</a> by Google.

This service is freely available to Google Chrome users. However, the API specification is not publicly available. To overcome this limitation <strong>we reverse-engineered the protocol to implement it in our tool</strong>.

Note that we need a token to use this API. To extract a valid token, the tool will spawn an instance of Google Chrome. You will need to be logged into the browser with a Google account to generate the token. We only use the token to emulate the requests generated by the browser to check the cracked passwords in the data breaches. However, we suggest using a secondary account for this purpose, to avoid any problems with your main Google account. To avoid launching the browser every time, the tool will save the token in the <code>refresh_token</code> file. If this file is found, the tool will check for the validity of the token, reusing it when possible.

</div>
<br>

<p align="center">
  <img class="aligncenter wp-image-2137 size-large" src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/04/leaked_password-e1682347213829-1024x504.png" alt="" width="640" height="315" />
</p>
<div></div>
<div>
<h4><strong>Levenshtein distance analysis</strong></h4>
In a lot of cases, we have access to both the current and previous passwords of the users. When this happens, it's interesting to check if the users tend to <strong>reuse always the same password with small changes</strong>. This is pretty common when users are required to change often their password and it basically defeats the purpose of password rotation. Evaluating this phenomenon and visualizing it clearly will help us in understanding if the policies for password changing are effective. For this purpose, we need to define a metric to measure how much two passwords differ. We want a number that summarizes if two passwords are similar to each other.

The <strong>Levenshtein distance</strong> is perfect for this purpose as it measures the "distance" between two strings. A low Levenshtein distance value means that the two strings are very similar to each other, while a high value means the opposite. To better understand this distance definition here are some examples:

</div>
<br>

<p align="center">
  <img class="aligncenter wp-image-2147 " src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/04/LEVENSHTEIN_EXAMPLES-1.png" alt="" width="473" height="226" />
</p>
<div></div>
<div>Right now, we perform this analysis by computing the distance between the current and the last changed password, without considering the complete password history.</div>
<br>

<p align="center">
  <img class="aligncenter wp-image-2136 size-large" src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/04/levenshtein_distance-e1682347258520-1024x507.png" alt="" width="640" height="317" />
</p>
<div>
<h4><strong>Common passwords</strong></h4>
Kraken also creates a <strong>ranking of the most common passwords</strong> in the cracked password list. This is useful to find more patterns in the password selection, for example, we can identify if a default password is used in the domain. This ranking could also be useful to extract a small set of passwords to add to the final report for the client when presenting the results.
<br>
<br>

<p align="center">
  <img class="aligncenter wp-image-2139" src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/04/common_password.png" alt="" width="392" height="163" />
</p>
<h4><strong>Common hashes</strong></h4>
Similarly to the common password ranking, in this case, we <strong>rank the most common password hashes</strong>. This allows us to identify common passwords that we weren't able to crack that could add more information to the previous analysis.

</div>
<br>
<p align="center">
  <img class="aligncenter wp-image-2223 " src="https://security.humanativaspa.it/sec/wp-content/uploads/2023/05/common_hash.png" alt="" width="544" height="182" />
</p>
<div>


## Usage
  
Kraken is pretty straightforward to use, but, at the same time, it allows customizing the report case by case.

In the most basic case, the tool takes the cracked password file as input and generates the report in the XLSX format. You can try it out with the following command.
<div>
<pre class="EnlighterJSRAW" data-enlighter-language="bash" data-enlighter-linenumbers="false">python kraken.py --pwd passwords.txt --out report.xlsx</pre>
</div>
The input file is expected in the format generated by hashcat, the current standard tool for password cracking. This format is pretty simple, every line contains a new set of credentials in the format "username:password". We also support the hexadecimal format used by hashcat to save passwords that contain special characters. In this case, the password is decoded automatically during the analysis. An example of a valid password file is the following:
<pre class="EnlighterJSRAW" data-enlighter-language="raw">username:password
user2:p4ssw0rd
anotheruser:$HEX[706124243a776f726421]</pre>
Note that the tool also supports the process of historical password data. Previous passwords are identified by appending to the username the suffix <code>_history</code> and an incremental number. For example, this file contains the password history for the user <code>username</code>.
<div>
<pre class="EnlighterJSRAW" data-enlighter-language="raw">username:currentpassword
username_history0:previouspassword
username_history1:oldpassword</pre>
</div>
In addition to the password file, the tool can take the following options as input.
<h4><strong>Group</strong></h4>
This option is used to define a list of users to be considered in the analysis. The information provided with this option has two purposes:
<ul>
 	<li> Customize what users to consider in the statistics without needing to modify the password file. In this way, we can limit the analysis to a group of users that we are interested in, ignoring the accounts that are not relevant to our purposes.</li>
</ul>
<ul>
 	<li> Adding the information about all the accounts defined in the domain, even the ones that we weren't able to crack.</li>
</ul>
This allows the tool to consider in the statistics the non-cracked passwords, providing a better overview of the results.

This option can be passed to the tool with the syntax <code>--group user_file.txt</code> where each line of the user file is a username that we want to consider in the analysis, as in the following example:

</div>
<div>
<pre class="EnlighterJSRAW" data-enlighter-language="raw">user
user1
user2</pre>
</div>
<h4><strong>Show not cracked</strong></h4>
This option is used to include the information about the non-cracked passwords, obtained from the group option, in the generated statistics. With this option, we can choose if we want to focus the analysis only on the passwords that we were able to crack or if want to give a complete overview of the results. This choice is a matter of personal preference and it depends on the actual distribution of the data. Indeed, including this information would make the generated charts <span data-dobid="hdw">unusable</span> if we cracked only a small portion of the passwords. However, if the portion of cracked passwords is significant adding this information will help give a better overview of the results.

You can toggle this flag by adding the <code>--show-not-cracked</code> option to the command.
<h4><strong>Dictionary</strong></h4>
As mentioned earlier, this option can be used to define new categories to be used in the password topology analysis. This is useful to customize the analysis and highlight some of the patterns that we identified in the cracked passwords. Indeed, it's pretty common to find out that a lot of passwords are based on some specific word. Usually, it is something related to the domain that we are testing, the most classic of examples is the name of the company. The tool will take each word in the dictionary file and it will use it to test the leaked passwords.

To check if a password is based on a specific word, we consider it case insensitive and we also consider substitutions of letters and numbers (leet). For example, if we added the word "password" in the dictionary all of the following strings will match it and will be categorized based on the word "password":
<ul>
 	<li>password123</li>
 	<li>aaaPassWOrd!</li>
 	<li>p4ssw0RD?</li>
</ul>
To use this option we can pass it to the tool with the syntax <code>--dictionary dictionary_file</code>. Each line of the dictionary file contains a word that we want to use to categorize passwords, as in the following example:
<div>
<pre class="EnlighterJSRAW" data-enlighter-language="raw">acme
2023
password</pre>
</div>
<div>
<h4><strong>Regex</strong></h4>
This option is similar to the dictionary option, but it allows us to be more flexible in the categorization of the passwords.

For example, if we want to highlight the passwords containing a date we could use a regex similar to <code>.*\d{8}.*</code>. This regex would match all of the following passwords:

</div>
<div>
<pre class="EnlighterJSRAW" data-enlighter-language="raw">02121999
test06072022
tt00000000!</pre>
</div>
<div>

To use this option we can pass it to the tool with the syntax <code>--regex regex_file.txt</code>. Each line of the regex file contains a python regex that will be used to match the cracked passwords, as in the following example:
<div>
<pre class="EnlighterJSRAW" data-enlighter-language="raw">p(a|4)s.+rd
.*\d{6}.*</pre>
</div>
<h4><strong>Pwdump file</strong></h4>
Kraken can also take as input the raw hash dump that we used in hashcat to crack the passwords. This file adds some information on all the passwords, even the ones that we weren't able to crack. At the moment this file is used only to generate the ranking of the most common password hashes available in the dump.

You can pass this option with the syntax <code>pwdump hash_dump_file.txt</code>. The file format expected by Kraken is the output format of <code>secretsdump.py</code>. An example of this file format is the following:
<div>
<pre class="EnlighterJSRAW" data-enlighter-language="raw">octagon.local\Administrator:500:aad3b435b51404eeaad3b435b51404ee:c8ca0f8d1f3ca975464bee8843bceda3:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:52db83a2f77be50bdb0f9cad2978d682:::
octagon.local\REVA_JOYCE:1103:aad3b435b51404eeaad3b435b51404ee:b2102052a134db43cdf57649d36aecbb:::
octagon.local\MARYANN_HANSON:1104:aad3b435b51404eeaad3b435b51404ee:57cbd01ad63e05402db21fb22cdedda2:::
octagon.local\MICHELLE_WOLF:1105:aad3b435b51404eeaad3b435b51404ee:65db1dfba7ef28bd9a95c2b4c0a8c213:::</pre>
</div>
<h4><strong>Check leaked</strong></h4>
With this option, you can enable the feature that checks the presence of cracked credentials in public data breaches. As described earlier, this feature supports two different APIs.

You can enable this analysis using the haveibeenpwned API by adding the flag <code>--check-leaked</code> in the command.

If you also what to enable the API used by Google password manager you can add the <code>--check-leaked-google</code> flag too.
